{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "effect-src",
  "type": "registry:lib",
  "title": "Effect Next.js",
  "author": "mcrovero",
  "description": "Effect helpers for Next.js (App Router). Installs entire src/ under lib/effect-nextjs.",
  "files": [
    {
      "path": "src/index.ts",
      "content": "/**\n * @since 0.5.0\n */\nexport * as Next from \"./Next.js\"\n\n/**\n * @since 0.5.0\n */\nexport * as NextMiddleware from \"./NextMiddleware.js\"\n",
      "type": "registry:lib",
      "target": "lib/effect-nextjs/index.ts"
    },
    {
      "path": "src/Next.ts",
      "content": "/**\n * @since 0.5.0\n */\nimport { Effect } from \"effect\"\nimport * as Context_ from \"effect/Context\"\nimport type * as Layer from \"effect/Layer\"\nimport * as ManagedRuntime from \"effect/ManagedRuntime\"\nimport type { Pipeable } from \"effect/Pipeable\"\nimport { pipeArguments } from \"effect/Pipeable\"\nimport type * as Schema from \"effect/Schema\"\nimport type * as AST from \"effect/SchemaAST\"\nimport { executeWithRuntime } from \"./internal/executor.js\"\nimport { createMiddlewareChain } from \"./internal/middleware-chain.js\"\nimport { getRuntime, setRuntime } from \"./internal/runtime-registry.js\"\nimport type * as NextMiddleware from \"./NextMiddleware.js\"\n\n/**\n * @since 0.5.0\n * @category constants\n */\nconst NextSymbolKey = \"@mcrovero/effect-nextjs/Next\"\n\n/**\n * @since 0.5.0\n * @category type ids\n */\nexport const TypeId: unique symbol = Symbol.for(NextSymbolKey)\n\n/**\n * Type alias for the unique `TypeId` symbol used to brand `Next`.\n *\n * @since 0.5.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * Minimal common surface shared by all `Next` constructors at runtime.\n *\n * This interface captures the brand, tag and unique key stored on the\n * constructor function value.\n *\n * @since 0.5.0\n * @category models\n */\nexport interface Any extends Pipeable {\n  readonly [TypeId]: TypeId\n  readonly _tag: string\n  readonly key: string\n}\n\n/**\n * Internal shape for `Next` constructors carrying configured middlewares and\n * an optional managed runtime.\n *\n * @since 0.5.0\n * @category models\n */\nexport interface AnyWithProps {\n  readonly [TypeId]: TypeId\n  readonly _tag: string\n  readonly key: string\n  readonly middlewares: ReadonlyArray<NextMiddleware.TagClassAnyWithProps>\n  readonly runtime?: ManagedRuntime.ManagedRuntime<any, any>\n}\n\n/**\n * Extracts the provided environment from a `Layer`.\n */\ntype LayerSuccess<L> = L extends Layer.Layer<infer ROut, any, any> ? ROut : never\n\n/**\n * Strongly-typed constructor for building Next.js handlers with Effect.\n *\n * - `Tag` is a string identifier for this handler family.\n * - `L` is an optional `Layer` to provision the Effect environment.\n * - `Middleware` is the union of middleware tags attached to the instance.\n *\n * Instances are constructor functions enriched with metadata and helper\n * methods, notably `middleware` for composition and `build` to produce an\n * async function consumable by Next.js.\n *\n * @since 0.5.0\n * @category models\n */\nexport interface Next<\n  in out Tag extends string,\n  out L extends Layer.Layer<any, any, any> | undefined,\n  out Middleware extends NextMiddleware.TagClassAny = never\n> extends Pipeable {\n  new(_: never): object\n\n  readonly [TypeId]: TypeId\n  readonly _tag: Tag\n  readonly key: string\n  readonly middlewares: ReadonlyArray<Middleware>\n  readonly runtime?: ManagedRuntime.ManagedRuntime<any, any>\n  readonly paramsSchema?: AnySchema\n  readonly searchParamsSchema?: AnySchema\n\n  /**\n   * Adds a middleware tag to this handler. The middleware must be satisfied by\n   * the environment provided by `L`.\n   */\n  middleware<M extends NextMiddleware.TagClassAny>(\n    middleware: Context_.Tag.Identifier<M> extends LayerSuccess<L> ? M : never\n  ): Next<Tag, L, Middleware | M>\n\n  /**\n   * Finalizes the handler by supplying an Effect-based implementation and\n   * returns an async function compatible with Next.js route APIs.\n   */\n  build<\n    A extends Array<any>,\n    O\n  >(\n    handler: BuildHandler<Next<Tag, L, Middleware>, A, O>\n  ): (\n    ...args: A\n  ) => Promise<\n    ReturnType<BuildHandler<Next<Tag, L, Middleware>, A, O>> extends Effect.Effect<infer _A, any, any> ?\n      _A | WrappedReturns<Middleware> :\n      never\n  >\n}\n\n/**\n * Prototype used to back `Next` constructor instances.\n *\n * @since 0.5.0\n * @category internal\n * @internal\n */\nconst Proto = {\n  [TypeId]: TypeId,\n  pipe() {\n    return pipeArguments(this, arguments)\n  },\n  /**\n   * Adds a middleware tag to this handler instance.\n   */\n  middleware(this: AnyWithProps, middleware: NextMiddleware.TagClassAny) {\n    if (this.runtime) {\n      return makeProto({\n        _tag: this._tag,\n        runtime: this.runtime,\n        middlewares: [...this.middlewares, middleware]\n      } as any)\n    }\n    return makeProto({\n      _tag: this._tag,\n      middlewares: [...this.middlewares, middleware]\n    } as any)\n  },\n\n  /**\n   * Binds an Effectful handler and produces an async function suitable for\n   * Next.js. It composes configured middlewares and executes within the\n   * associated `ManagedRuntime` when present (supporting HMR in dev).\n   */\n  build<\n    A extends Array<any>,\n    O\n  >(\n    this: AnyWithProps,\n    handler: (\n      ...args: A\n    ) => Effect.Effect<O, any, any>\n  ) {\n    const runtime = this.runtime\n    return async (...args: A) => {\n      const middlewares = this.middlewares\n\n      const program = Effect.gen(function*() {\n        const context = yield* Effect.context<never>()\n\n        let handlerEffect = handler(...args)\n\n        if (middlewares.length > 0) {\n          const tags = middlewares\n          handlerEffect = createMiddlewareChain(\n            tags,\n            (tag) => Context_.unsafeGet(context, tag),\n            handlerEffect,\n            { props: args }\n          )\n        }\n        return yield* handlerEffect\n      })\n      /**\n       * In development we use global registry to get the runtime\n       * to support hot-reloading.\n       */\n      if (runtime) {\n        const actualRuntime = getRuntime(`${NextSymbolKey}/${this._tag}`, runtime)\n        return executeWithRuntime(actualRuntime, program as Effect.Effect<any, any, never>)\n      }\n      return executeWithRuntime(undefined, program as Effect.Effect<any, any, never>)\n    }\n  }\n}\nconst makeProto = <\n  const Tag extends string,\n  const L extends Layer.Layer<any, any, any> | undefined,\n  Middleware extends NextMiddleware.TagClassAny\n>(options: {\n  readonly _tag: Tag\n  readonly runtime?: ManagedRuntime.ManagedRuntime<any, any>\n  readonly middlewares: ReadonlyArray<Middleware>\n  readonly paramsSchema?: AnySchema\n  readonly searchParamsSchema?: AnySchema\n}): Next<Tag, L, Middleware> => {\n  /**\n   * @internal Internal constructor function used as the value of a `Next`\n   * instance. The function itself is never called; it exists to carry the\n   * prototype and static props.\n   */\n  function Next() {}\n  Object.setPrototypeOf(Next, Proto)\n  Object.assign(Next, options)\n  Next.key = `${NextSymbolKey}/${options._tag}`\n  return Next as any\n}\n\n/**\n * Creates a `Next` handler constructor without providing a `Layer`.\n *\n * @since 0.5.0\n * @category constructors\n */\nexport function make<const Tag extends string>(tag: Tag): Next<Tag, undefined>\nexport function make<\n  const Tag extends string,\n  const L extends Layer.Layer<any, any, never>\n>(\n  tag: Tag,\n  layer: L\n): Next<Tag, L>\nexport function make(tag: string, layer?: Layer.Layer<any, any, never>): Next<any, any> {\n  if (layer) {\n    const runtime = ManagedRuntime.make(layer)\n    setRuntime(`${NextSymbolKey}/${tag}`, runtime)\n    return makeProto({\n      _tag: tag as any,\n      runtime,\n      middlewares: [] as Array<never>\n    })\n  }\n  return makeProto({\n    _tag: tag as any,\n    middlewares: [] as Array<never>\n  })\n}\n\n/**\n * Computes the environment required by a `Next` handler: the environment\n * provided by its `Layer` plus any environments declared by middleware tags.\n */\ntype ExtractProvides<R extends Any> = R extends Next<\n  infer _Tag,\n  infer _Layer,\n  infer _Middleware\n> ?\n    | LayerSuccess<_Layer>\n    | (_Middleware extends { readonly provides: Context_.Tag<infer _I, any> } ? _I : never)\n  : never\n\n/**\n * Signature of the effectful handler accepted by `build`.\n *\n * - `A` are the runtime arguments of the produced async function\n * - `O` is the success value of the effect\n * - The error channel is constrained by the union of middleware \"catches\"\n * - The required environment is computed from the `Next` instance\n */\ntype BuildHandler<P extends Any, A extends Array<any>, O> = P extends\n  Next<infer _Tag, infer _Layer, infer _Middleware> ? (\n    ...args: A\n  ) => Effect.Effect<O, CatchesFromMiddleware<_Middleware>, ExtractProvides<P>> :\n  never\n\n/** Extracts the output type from a `Schema`. */\ntype InferSchemaOutput<S> = S extends Schema.Schema<infer A, any, any> ? A : never\n/**\n * Computes the wrapped return type produced by middleware implementing the\n * `wrap` protocol. When no wrapper is present, yields `never`.\n */\ntype WrappedReturns<M> = M extends { readonly wrap: true }\n  ? InferSchemaOutput<M extends { readonly returns: infer S } ? S : typeof Schema.Never>\n  : never\n\n/** Extracts the union of error types that middleware can catch. */\ntype CatchesFromMiddleware<M> = M extends { readonly catches: Schema.Schema<infer A, any, any> } ? A : never\n\n/**\n * Minimal structural view of a `Schema` used here to avoid pulling concrete\n * schema types into the public surface area.\n *\n * @since 0.5.0\n * @category models\n */\ninterface AnySchema extends Pipeable {\n  readonly [Schema.TypeId]: any\n  readonly Type: any\n  readonly Encoded: any\n  readonly Context: any\n  readonly make?: (params: any, ...rest: ReadonlyArray<any>) => any\n  readonly ast: AST.AST\n}\n",
      "type": "registry:lib",
      "target": "lib/effect-nextjs/Next.ts"
    },
    {
      "path": "src/NextMiddleware.ts",
      "content": "/**\n * @since 0.5.0\n */\nimport * as Context from \"effect/Context\"\nimport type * as Effect from \"effect/Effect\"\nimport * as Effect_ from \"effect/Effect\"\nimport type * as Layer from \"effect/Layer\"\nimport * as Layer_ from \"effect/Layer\"\nimport * as Schema from \"effect/Schema\"\nimport type { Mutable } from \"effect/Types\"\n\n/**\n * @since 0.5.0\n * @category type ids\n */\nexport const TypeId: unique symbol = Symbol.for(\"@mcrovero/effect-nextjs/Middleware\")\n\n/**\n * Type alias for the unique `TypeId` used to brand middleware tag classes.\n *\n * @since 0.5.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * Internal options passed to middleware implementations.\n *\n * - `props` carries arguments from the outer handler (e.g. request params)\n */\ntype MiddlewareOptions = {\n  props: unknown\n}\n\n/**\n * Simple middleware contract.\n *\n * Produces or validates part of the environment (`Provides`), can fail with\n * `E`, and requires environment `R`.\n *\n * @since 0.5.0\n * @category models\n */\nexport interface NextMiddleware<Provides, E, R = never> {\n  (options: MiddlewareOptions): Effect.Effect<Provides, E, R>\n}\n\n/**\n * Wrapper middleware contract.\n *\n * Intercepts execution by receiving a `next` effect. It can catch structured\n * errors (`Catches`) from `next` and map them to success. It requires\n * environment `R` and returns any value (often response-like).\n *\n * @since 0.5.0\n * @category models\n */\nexport interface NextMiddlewareWrap<Provides, Catches, R> {\n  (\n    options: MiddlewareOptions & { readonly next: Effect.Effect<any, Catches, Provides> }\n  ): Effect.Effect<any, never, R>\n}\n\n/**\n * Erased middleware function shape used internally for dynamic composition.\n *\n * @since 0.5.0\n * @category models\n */\nexport interface Any {\n  (options: { readonly payload: unknown; readonly next?: Effect.Effect<any, any, any> }): Effect.Effect<any, any, any>\n}\n\n/**\n * Strongly-typed tag class representing a middleware capability.\n *\n * The concrete service type depends on whether the tag is a wrapper (`wrap`\n * true) or a regular middleware.\n *\n * @since 0.5.0\n * @category models\n */\nexport type TagClass<Self, Name extends string, Options, R> = TagClass.Base<\n  Self,\n  Name,\n  Options,\n  TagClass.Wrap<Options> extends true\n    ? NextMiddlewareWrap<TagClass.Provides<Options>, TagClass.CatchesValue<Options>, R>\n    : NextMiddleware<TagClass.Service<Options>, TagClass.FailureService<Options>, R>\n>\n\n/**\n * @since 0.5.0\n * @category models\n */\nexport declare namespace TagClass {\n  /**\n   * Extracts the identifier type of the provided `Context.Tag`.\n   *\n   * @since 0.5.0\n   * @category models\n   */\n  export type Provides<Options> = Options extends {\n    readonly provides: Context.Tag<any, any>\n  } ? Context.Tag.Identifier<Options[\"provides\"]>\n    : never\n\n  /**\n   * Service value provided by the middleware when `provides` is specified.\n   *\n   * @since 0.5.0\n   * @category models\n   */\n  export type Service<Options> = Options extends {\n    readonly provides: Context.Tag<any, any>\n  } ? Context.Tag.Service<Options[\"provides\"]>\n    : void\n\n  /**\n   * Schema describing failures that the middleware may raise.\n   *\n   * @since 0.5.0\n   * @category models\n   */\n  export type FailureSchema<Options> = Options extends {\n    readonly failure: Schema.Schema.All\n  } ? Options[\"failure\"]\n    : typeof Schema.Never\n\n  /**\n   * Decoded failure value type from `FailureSchema`.\n   *\n   * @since 0.5.0\n   * @category models\n   */\n  export type Failure<Options> = Options extends {\n    readonly failure: Schema.Schema<infer _A, infer _I, infer _R>\n  } ? _A\n    : never\n\n  /**\n   * Context required to decode failures for the schema.\n   *\n   * @since 0.5.0\n   * @category models\n   */\n  export type FailureContext<Options> = Schema.Schema.Context<FailureSchema<Options>>\n\n  /**\n   * Alias of `Failure` to emphasize the value-level failure channel.\n   *\n   * @since 0.5.0\n   * @category models\n   */\n  export type FailureService<Options> = Failure<Options>\n\n  /**\n   * Whether the middleware is a wrapper (receives `next`).\n   *\n   * @since 0.5.0\n   * @category models\n   */\n  export type Wrap<Options> = Options extends { readonly wrap: true } ? true : false\n\n  /**\n   * Schema of errors that a wrapper middleware can catch from `next`.\n   *\n   * @since 0.5.0\n   * @category models\n   */\n  export type CatchesSchema<Options> = Wrap<Options> extends true\n    ? Options extends { readonly catches: Schema.Schema.All } ? Options[\"catches\"] : typeof Schema.Never\n    : typeof Schema.Never\n\n  /**\n   * Decoded value type of the `catches` schema.\n   *\n   * @since 0.5.0\n   * @category models\n   */\n  export type CatchesValue<Options> = CatchesSchema<Options> extends Schema.Schema<infer A, any, any> ? A : never\n\n  /**\n   * Schema describing additional wrapped return value produced by wrapper\n   * middlewares.\n   *\n   * @since 0.5.0\n   * @category models\n   */\n  export type ReturnsSchema<Options> = Wrap<Options> extends true\n    ? Options extends { readonly returns: Schema.Schema.All } ? Options[\"returns\"] : typeof Schema.Never\n    : typeof Schema.Never\n\n  /**\n   * Base structural shape of a middleware tag class.\n   *\n   * @since 0.5.0\n   * @category models\n   */\n  export interface Base<Self, Name extends string, Options, Service> extends Context.Tag<Self, Service> {\n    new(_: never): Context.TagClassShape<Name, Service>\n    readonly [TypeId]: TypeId\n    readonly failure: FailureSchema<Options>\n    readonly catches: CatchesSchema<Options>\n    readonly provides: Options extends { readonly provides: Context.Tag<any, any> } ? Options[\"provides\"] : undefined\n    readonly wrap: Wrap<Options>\n    readonly returns: ReturnsSchema<Options>\n  }\n}\n\n/**\n * Erased view of a middleware tag class (no generic parameters).\n *\n * @since 0.5.0\n * @category models\n */\nexport interface TagClassAny extends Context.Tag<any, any> {\n  readonly [TypeId]: TypeId\n  readonly provides?: Context.Tag<any, any> | undefined\n  readonly failure: Schema.Schema.All\n  readonly catches: Schema.Schema.All\n  readonly wrap: boolean\n  readonly returns: Schema.Schema.All\n}\n\n/**\n * Erased tag class variant whose service is a concrete middleware function.\n * Used by the middleware chain during execution.\n *\n * @since 0.5.0\n * @category models\n */\nexport interface TagClassAnyWithProps\n  extends Context.Tag<any, NextMiddleware<any, any, any> | NextMiddlewareWrap<any, any, any>>\n{\n  readonly [TypeId]: TypeId\n  readonly provides?: Context.Tag<any, any> | undefined\n  readonly failure: Schema.Schema.All\n  readonly catches: Schema.Schema.All\n  readonly wrap: boolean\n  readonly returns: Schema.Schema.All\n}\n\n/**\n * Creates a strongly-typed middleware tag class.\n *\n * Overloaded on `Options.wrap` to produce either a wrapper or a simple\n * middleware. Optional `failure`, `provides`, `catches`, and `returns` schemas\n * configure type-level behavior and runtime metadata.\n *\n * @since 0.5.0\n * @category tags\n */\nexport const Tag = <Self>(): <\n  const Name extends string,\n  const Options extends (\n    | {\n      readonly wrap: true\n      readonly failure?: Schema.Schema.All\n      readonly provides?: Context.Tag<any, any>\n      readonly catches?: Schema.Schema.All\n      readonly returns?: Schema.Schema.All\n    }\n    | {\n      readonly wrap?: false\n      readonly failure?: Schema.Schema.All\n      readonly provides?: Context.Tag<any, any>\n      readonly catches?: undefined\n    }\n  )\n>(\n  id: Name,\n  options?: Options | undefined\n) => TagClass<Self, Name, Options, never> =>\n(\n  id: string,\n  options?: any\n) => {\n  const Err = globalThis.Error as any\n  const limit = Err.stackTraceLimit\n  Err.stackTraceLimit = 2\n  const creationError = new Err()\n  Err.stackTraceLimit = limit\n\n  function TagClass() {}\n  const TagClass_ = TagClass as any as Mutable<TagClassAny>\n  Object.setPrototypeOf(TagClass, Object.getPrototypeOf(Context.GenericTag<Self, any>(id)))\n  TagClass.key = id\n  Object.defineProperty(TagClass, \"stack\", {\n    get() {\n      return creationError.stack\n    }\n  })\n  TagClass_[TypeId] = TypeId\n  TagClass_.failure = options?.failure === undefined ? Schema.Never : options.failure\n  ;(TagClass_ as any).catches = options && (options as any).wrap === true && (options as any).catches !== undefined\n    ? (options as any).catches\n    : Schema.Never\n  if (options?.provides) {\n    TagClass_.provides = options.provides\n  }\n  TagClass_.wrap = options?.wrap ?? false\n  ;(TagClass_ as any).returns = options && (options as any).wrap === true && (options as any).returns !== undefined\n    ? (options as any).returns\n    : Schema.Never\n  return TagClass as any\n}\n\n/** Infers the required environment `R` from an implementation function. */\ntype InferRFromImpl<Impl> = Impl extends (options: any) => Effect.Effect<any, any, infer R> ? R : never\n\n/** Extracts the provided service type from a tag's `provides` property. */\ntype ProvidedService<M> = M extends { readonly provides: Context.Tag<any, infer S> } ? S : never\n\n/** Decodes the failure value from a tag's `failure` schema. */\ntype FailureFromTag<M> = M extends { readonly failure: Schema.Schema<infer A, any, any> } ? A : never\n\n/**\n * Builds a `Layer` from a middleware tag and its effectful implementation.\n *\n * The resulting layer registers the implementation under the tag in the\n * environment so that the middleware chain can retrieve and invoke it.\n */\nexport function layer<\n  M extends TagClassAny,\n  Impl extends (\n    options:\n      & MiddlewareOptions\n      & (\n        M[\"wrap\"] extends true ? { readonly next: Effect.Effect<any, TagClass.CatchesValue<M>, ProvidedService<M>> }\n          : unknown\n      )\n  ) => Effect.Effect<\n    M[\"wrap\"] extends true ? any : ProvidedService<M>,\n    M[\"wrap\"] extends true ? never : FailureFromTag<M>,\n    InferRFromImpl<Impl>\n  >\n>(\n  tag: M,\n  impl: Impl\n): Layer.Layer<Context.Tag.Identifier<M>, never, Exclude<InferRFromImpl<Impl>, ProvidedService<M>>> {\n  return Layer_.effect(tag as any, Effect_.as(Effect_.context<any>() as any, impl as any)) as any\n}\n",
      "type": "registry:lib",
      "target": "lib/effect-nextjs/NextMiddleware.ts"
    },
    {
      "path": "src/internal/executor.ts",
      "content": "import { Cause, Effect, Exit } from \"effect\"\nimport type * as ManagedRuntime from \"effect/ManagedRuntime\"\n\n/**\n * @since 0.5.0\n * @category utils\n */\nexport const executeWithRuntime = async <A>(\n  runtime: ManagedRuntime.ManagedRuntime<any, any> | undefined,\n  effect: Effect.Effect<A, any, never>\n): Promise<A> => {\n  const result = runtime\n    ? await runtime.runPromiseExit(effect as Effect.Effect<A, any, never>)\n    : await Effect.runPromiseExit(effect as Effect.Effect<A, any, never>)\n  if (Exit.isFailure(result)) {\n    const mappedError = Cause.match<any, any>(result.cause, {\n      onEmpty: () => new Error(\"empty\"),\n      onFail: (error_1) => error_1,\n      onDie: (defect_1) => defect_1,\n      onInterrupt: (fiberId_1) => new Error(`Interrupted`, { cause: fiberId_1 }),\n      onSequential: (left_1, right) => new Error(`Sequential (left: ${left_1}) (right: ${right})`),\n      onParallel: (left_3, right_1) => new Error(`Parallel (left: ${left_3}) (right: ${right_1})`)\n    })\n\n    const effectPretty = Cause.pretty(result.cause as any)\n    if (effectPretty && typeof effectPretty === \"string\" && mappedError instanceof Error) {\n      mappedError.stack = effectPretty\n    }\n    throw mappedError\n  }\n  return result.value\n}\n",
      "type": "registry:lib",
      "target": "lib/effect-nextjs/internal/executor.ts"
    },
    {
      "path": "src/internal/middleware-chain.ts",
      "content": "import type { Effect } from \"effect/Effect\"\nimport * as Effect_ from \"effect/Effect\"\nimport type * as NextMiddleware from \"../NextMiddleware.js\"\n\n/**\n * @since 0.5.0\n * @category utils\n */\nexport const createMiddlewareChain = (\n  tags: ReadonlyArray<NextMiddleware.TagClassAny>,\n  resolve: (tag: NextMiddleware.TagClassAny) => any,\n  base: Effect<any, any, any>,\n  options: { props: unknown }\n): Effect<any, any, any> => {\n  const buildChain = (index: number): Effect<any, any, any> => {\n    if (index >= tags.length) {\n      return base\n    }\n    const tag = tags[index]\n    const middleware = resolve(tag)\n    const tail = buildChain(index + 1)\n    if (tag.wrap) {\n      return middleware({ ...options, next: tail })\n    }\n    return tag.provides !== undefined\n      ? Effect_.provideServiceEffect(\n        tail,\n        tag.provides as any,\n        middleware(options) as any\n      )\n      : Effect_.zipRight(\n        middleware(options) as any,\n        tail\n      )\n  }\n  return buildChain(0)\n}\n",
      "type": "registry:lib",
      "target": "lib/effect-nextjs/internal/middleware-chain.ts"
    },
    {
      "path": "src/internal/runtime-registry.ts",
      "content": "import type * as ManagedRuntime from \"effect/ManagedRuntime\"\n\n/**\n * Runtime Registry for Hot Module Replacement (HMR) Support\n *\n * This utility is essential for supporting Hot Module Replacement in development environments.\n * Without it, HMR would break Effect-based Next.js applications due to runtime lifecycle issues.\n *\n * Usage:\n * - setRuntime(tag, runtime): Store runtime in registry (dev) or noop (prod)\n * - getRuntime(tag, fallback): Get runtime from registry (dev) or return fallback (prod)\n *\n * This ensures HMR works seamlessly while maintaining performance in production.\n */\ndeclare global {\n  var __effect_nextjs_runtime_registry__:\n    | Record<string, ManagedRuntime.ManagedRuntime<any, any> | undefined>\n    | undefined\n}\n\n/**\n * Sets a runtime in the global registry for development mode.\n * In production, this is a no-op.\n *\n * @param runtimeTag - The tag to identify the runtime\n * @param runtime - The runtime to register\n */\nexport const setRuntime = (\n  key: string,\n  runtime: ManagedRuntime.ManagedRuntime<any, any>\n): void => {\n  const isDev = process.env.NODE_ENV !== \"production\"\n  if (!isDev) return\n\n  const registry = (globalThis.__effect_nextjs_runtime_registry__ = globalThis.__effect_nextjs_runtime_registry__ ?? {})\n\n  // Dispose of previous runtime if it exists to prevent memory leaks\n  const previous = registry[key]\n  if (previous && typeof previous.dispose === \"function\") {\n    // fire-and-forget: ensure previous scoped resources/fibers are finalized\n    void previous.dispose()\n  }\n\n  registry[key] = runtime\n}\n\n/**\n * Gets a runtime from the global registry for development mode.\n * In production or if no runtime is found in the registry, returns the provided fallback runtime.\n *\n * @param key - The key to identify the runtime\n * @param fallbackRuntime - The runtime to use as fallback\n * @returns The runtime from registry (dev) or the fallback runtime (prod/no registry)\n */\nexport const getRuntime = <T extends ManagedRuntime.ManagedRuntime<any, any>>(\n  key: string,\n  fallbackRuntime: T\n): T => {\n  const isDev = process.env.NODE_ENV !== \"production\"\n  if (!isDev) return fallbackRuntime\n\n  const registry = globalThis.__effect_nextjs_runtime_registry__\n  if (registry && registry[key]) {\n    return registry[key] as T\n  }\n\n  return fallbackRuntime\n}\n",
      "type": "registry:lib",
      "target": "lib/effect-nextjs/internal/runtime-registry.ts"
    }
  ],
  "categories": [
    "nextjs",
    "lib"
  ]
}